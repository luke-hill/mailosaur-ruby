# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Mailosaur
  #
  # # Introduction
  #
  # This is an overview of the Mailosaur API. This API a RESTful JSON interface
  # with predictable, resource-oriented URLs. We make use of HTTP response
  # codes to indicate
  # API errors.
  #
  # We use built-in HTTP features, like HTTP authentication and HTTP verbs,
  # which are understood
  # by off-the-shelf HTTP clients.
  #
  # [Official client libraries](/docs/client-libraries/) available for most
  # popular languages.
  #
  # # Authentication
  #
  # Authenticate your account when using the API by including your API key in
  # the request.
  # You can [manage your API keys](/app/account/api-access/) in the Mailosaur
  # UI. Your API key carrys many privileges,
  # so be sure to keep it secret! Do not share your API key in
  # publicly-accessible areas such
  # GitHub, client-side code, and so on.
  #
  # All API requests must be made over HTTPS. Calls made over plain HTTP will
  # fail.
  # API requests without authentication will also fail.
  #
  # # Errors
  #
  # ## HTTP status codes
  #
  # Mailosaur uses conventional HTTP response codes to indicate the success or
  # failure of an
  # API request. In general, codes in the `2xx` range indicate success, codes
  # in the `4xx` range
  # indicate an error that failed given the information provided (e.g., a
  # required parameter
  # was omitted), and codes in the `5xx` range indicate an error with
  # Mailosaur's servers (give us a shout in the unlikely event that you see one
  # of those).
  #
  # | Code | Description |
  # |---|---|
  # | 200 - OK | Request was successful. |
  # | 204 - No Content | Request was successful, no response content. |
  # | 400 - Bad Request | The request could be handled, often due to missing a
  # required parameter. |
  # | 401 - Unauthorized | No valid API key provided. |
  # | 404 - Not Found | The requested resource doesn't exist. |
  # | 5XX - Server Errors | Something went wrong at Mailosaur. (Give us a
  # shout). |
  #
  # ## Error handling
  #
  # In of an error the server will return as much information as possible. In
  # the case of a `401` or
  # `404` error the status code gives as much information as you'd need. But
  # for `400` errors
  # Mailosaur will return a JSON object containing the structure below.
  #
  # Note that our client libraries convert responses to appropriate
  # language-specific objects.
  #
  # | Property | Description |
  # |---|---|
  # | `type` | The type of error returned. Can be: api_connection_error,
  # api_error, authentication_error, card_error, idempotency_error
  # invalid_request_error, or rate_limit_error. |
  # | `message` | A human-readable message providing more details about the
  # error. |
  # | `parameters` | A JSON object containing a key for each property name at
  # fault, with a human-readable message per field |
  # | `model` | The request model that we sent and failed to be processed |
  #
  class Messages

    #
    # Creates and initializes a new instance of the Messages class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [MailosaurBaseClient] reference to the MailosaurBaseClient
    attr_reader :client

    #
    # Retrieve a message
    #
    # Retrieves the detail for a single email message. Simply supply the unique
    # identifier for the required message.
    #
    # @param id The identifier of the email message to be retrieved.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Message] operation results.
    #
    def get(id, custom_headers:nil)
      response = get_async(id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieve a message
    #
    # Retrieves the detail for a single email message. Simply supply the unique
    # identifier for the required message.
    #
    # @param id The identifier of the email message to be retrieved.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_with_http_info(id, custom_headers:nil)
      get_async(id, custom_headers:custom_headers).value!
    end

    #
    # Retrieve a message
    #
    # Retrieves the detail for a single email message. Simply supply the unique
    # identifier for the required message.
    #
    # @param id The identifier of the email message to be retrieved.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/messages/{id}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::Message.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete a message
    #
    # Permanently deletes a message. This operation cannot be undone. Also deletes
    # any attachments related to the message.
    #
    # @param id The identifier of the message to be deleted.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete(id, custom_headers:nil)
      response = delete_async(id, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete a message
    #
    # Permanently deletes a message. This operation cannot be undone. Also deletes
    # any attachments related to the message.
    #
    # @param id The identifier of the message to be deleted.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_with_http_info(id, custom_headers:nil)
      delete_async(id, custom_headers:custom_headers).value!
    end

    #
    # Delete a message
    #
    # Permanently deletes a message. This operation cannot be undone. Also deletes
    # any attachments related to the message.
    #
    # @param id The identifier of the message to be deleted.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_async(id, custom_headers:nil)
      fail ArgumentError, 'id is nil' if id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/messages/{id}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'id' => id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end


        result
      end

      promise.execute
    end

    #
    # List all messages
    #
    # Returns a list of your messages in summary form. The summaries are returned
    # sorted by received date, with the most recently-received messages appearing
    # first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MessageListResult] operation results.
    #
    def list(server, page:nil, items_per_page:nil, custom_headers:nil)
      response = list_async(server, page:page, items_per_page:items_per_page, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all messages
    #
    # Returns a list of your messages in summary form. The summaries are returned
    # sorted by received date, with the most recently-received messages appearing
    # first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_with_http_info(server, page:nil, items_per_page:nil, custom_headers:nil)
      list_async(server, page:page, items_per_page:items_per_page, custom_headers:custom_headers).value!
    end

    #
    # List all messages
    #
    # Returns a list of your messages in summary form. The summaries are returned
    # sorted by received date, with the most recently-received messages appearing
    # first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_async(server, page:nil, items_per_page:nil, custom_headers:nil)
      fail ArgumentError, 'server is nil' if server.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/messages'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'server' => server,'page' => page,'itemsPerPage' => items_per_page},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::MessageListResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Delete all messages
    #
    # Permanently deletes all messages held by the specified server. This operation
    # cannot be undone. Also deletes any attachments related to each message.
    #
    # @param server [String] The identifier of the server to be emptied.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_all(server, custom_headers:nil)
      response = delete_all_async(server, custom_headers:custom_headers).value!
      nil
    end

    #
    # Delete all messages
    #
    # Permanently deletes all messages held by the specified server. This operation
    # cannot be undone. Also deletes any attachments related to each message.
    #
    # @param server [String] The identifier of the server to be emptied.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_all_with_http_info(server, custom_headers:nil)
      delete_all_async(server, custom_headers:custom_headers).value!
    end

    #
    # Delete all messages
    #
    # Permanently deletes all messages held by the specified server. This operation
    # cannot be undone. Also deletes any attachments related to each message.
    #
    # @param server [String] The identifier of the server to be emptied.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_all_async(server, custom_headers:nil)
      fail ArgumentError, 'server is nil' if server.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'api/messages'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'server' => server},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end


        result
      end

      promise.execute
    end

    #
    # Search for messages
    #
    # Returns a list of messages matching the specified search criteria, in summary
    # form. The messages are returned sorted by received date, with the most
    # recently-received messages appearing first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param criteria [SearchCriteria] The search criteria to match results
    # against.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MessageListResult] operation results.
    #
    def search(server, criteria, page:nil, items_per_page:nil, custom_headers:nil)
      response = search_async(server, criteria, page:page, items_per_page:items_per_page, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Search for messages
    #
    # Returns a list of messages matching the specified search criteria, in summary
    # form. The messages are returned sorted by received date, with the most
    # recently-received messages appearing first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param criteria [SearchCriteria] The search criteria to match results
    # against.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def search_with_http_info(server, criteria, page:nil, items_per_page:nil, custom_headers:nil)
      search_async(server, criteria, page:page, items_per_page:items_per_page, custom_headers:custom_headers).value!
    end

    #
    # Search for messages
    #
    # Returns a list of messages matching the specified search criteria, in summary
    # form. The messages are returned sorted by received date, with the most
    # recently-received messages appearing first.
    #
    # @param server [String] The identifier of the server hosting the messages.
    # @param criteria [SearchCriteria] The search criteria to match results
    # against.
    # @param page [Integer] Used in conjunction with `itemsPerPage` to support
    # pagination.
    # @param items_per_page [Integer] A limit on the number of results to be
    # returned per page. Can be set between 1 and 1000 items, the default is 50.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def search_async(server, criteria, page:nil, items_per_page:nil, custom_headers:nil)
      fail ArgumentError, 'server is nil' if server.nil?
      fail ArgumentError, 'criteria is nil' if criteria.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Mailosaur::Models::SearchCriteria.mapper()
      request_content = @client.serialize(request_mapper,  criteria)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'api/messages/search'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'server' => server,'page' => page,'itemsPerPage' => items_per_page},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          mailosaur_error = Mailosaur::MailosaurError.new('Operation returned an invalid status code \'' + status_code.to_s + '\'', error_model)
          raise mailosaur_error
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Mailosaur::Models::MessageListResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Wait for a specific message
    #
    # Returns as soon as a message matching the specified search criteria is found or timeout has elapsed.
    # This is the most efficient method of looking up a message.
    #
    # @param server [String] The identifier of the server hosting the message.
    # @param criteria [SearchCriteria] The search criteria to use in order to find
    # a match.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    # @param timeout [Integer] Timeout in seconds (15s default).
    #
    # @return [Message] operation results.
    #
    def wait_for(server, criteria, custom_headers:nil, timeout:15)
      response = wait_for_async(server, criteria, custom_headers:custom_headers, timeout:timeout).value!
      response.body unless response.nil?
    end

    #
    # Wait for a specific message
    #
    # Returns as soon as a message matching the specified search criteria is found or timeout has elapsed.
    # This is the most efficient method of looking up a message.
    #
    # @param server [String] The identifier of the server hosting the message.
    # @param criteria [SearchCriteria] The search criteria to use in order to find
    # a match.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    # @param timeout [Integer] Timeout in seconds (15s default).    
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def wait_for_with_http_info(server, criteria, custom_headers:nil, timeout:15)
      wait_for_async(server, criteria, custom_headers:custom_headers, timeout:timeout).value!
    end

    #
    # Wait for a specific message
    #
    # Returns as soon as a message matching the specified search criteria is found or timeout has elapsed.
    # This is the most efficient method of looking up a message.
    #
    # @param server [String] The identifier of the server hosting the message.
    # @param criteria [SearchCriteria] The search criteria to use in order to find
    # a match.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    # @param timeout [Integer] Timeout in seconds (15s default).    
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def wait_for_async(server, criteria, custom_headers:nil, timeout:15)
      fail ArgumentError, 'server is nil' if server.nil?
      fail ArgumentError, 'criteria is nil' if criteria.nil?

      timeout_datetime = DateTime.now + Rational(timeout, 86400)

      while timeout_datetime > DateTime.now
        messages = search(server, criteria, page:0, items_per_page:1, custom_headers:custom_headers)
        if messages.items.length > 0
          return get_async(messages.items[0].id, custom_headers:custom_headers)
        end

        sleep(2)
      end

      mailosaur_error = Mailosaur::MailosaurError.new('wait_for timeout elapsed', nil)
      raise mailosaur_error
    end

  end
end
